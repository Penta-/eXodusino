/* mbed Nokia LCD Library
 * Atsu
 */

#include "delay.h"
#include "maryoled.h"
#include <math.h>

/** General parameters for MARMEX_OB_oled */

#define	MARYOLED_ROWS	15
#define	MARYOLED_COLS	16
#define	MARYOLED_WIDTH	128
#define	MARYOLED_HEIGHT	128
#define	MARYOLED_FREQUENCY	20000000

//MARY Pin Assign
//#define OLED_VCC_ON	C21
//#define OLED_CS		C33
//#define OLED_RES	C31

//LPCXpresso pin Assign (MARMEX-SLOT1)
//#define OLED_VCC_ON	P0_7
//#define OLED_CS		P0_2
//#define OLED_RES	P0_1

MARYOLED oled;

MARYOLED::MARYOLED()	//default : MARY
{
	this->OLED_VCC_ON = C21;
	this->OLED_CS = C33;
	this->OLED_RES = C31;
    this->device = OLED;
    port = marySSP0;
    _row = 0;
    _column = 0;
    _foreground = 0x00FFFFFF;
    _background = 0x00000000;

}

MARYOLED::~MARYOLED()
{
}
void MARYOLED::reset(SSP_PORT port)
{
	this->port = port;
	if(port==LPCXSSP0)	//LPCXpresso 1114 + MAPLE
	{
		this->OLED_VCC_ON = P0_7;
		this->OLED_CS = P0_2;
		this->OLED_RES = P0_1;
	}
	pinMode(OLED_VCC_ON,OUTPUT);
	pinMode(OLED_RES,OUTPUT);
	pinMode(OLED_CS,OUTPUT);

	digitalWrite(OLED_RES,HIGH);
	digitalWrite(OLED_VCC_ON,LOW);

	reset();
	return;
}
void MARYOLED::reset() {
	#define GAMMA_LUT_SIZE 63
	//unsigned char    gamma_LUT[ GAMMA_LUT_SIZE ];

	//for ( int i = 0; i < GAMMA_LUT_SIZE; i++ )
		//gamma_LUT[ i ]  = (unsigned char)(powf( ((float)i / 62.0), (1.0 / 0.58) ) * 178.0 + 2.0);
	unsigned char gamma_LUT[63] =
	{
	    0x02, 0x03, 0x04, 0x05,
	    0x06, 0x07, 0x08, 0x09,
	    0x0a, 0x0b, 0x0c, 0x0d,
	    0x0e, 0x0f, 0x10, 0x11,
	    //
	    0x12, 0x13, 0x15, 0x17,
	    0x19, 0x1b, 0x1d, 0x1f,
	    0x21, 0x23, 0x25, 0x27,
	    0x2a, 0x2d, 0x30, 0x33,
	    //
	    0x36, 0x39, 0x3c, 0x3f,
	    0x42, 0x45, 0x48, 0x4c,
	    0x50, 0x54, 0x58, 0x5c,
	    0x60, 0x64, 0x68, 0x6c,
	    //
	    0x70, 0x74, 0x78, 0x7d,
	    0x82, 0x87, 0x8c, 0x91,
	    0x96, 0x9b, 0xa0, 0xa5,
	    0xaa, 0xaf, 0xb4
	};

	// setup the _spi interface and bring display out of reset
	digitalWrite( OLED_CS, HIGH );
	digitalWrite( OLED_RES, LOW );


	SPI.setBitLength( 9 ); //9bit mode
	SPI.setDataMode(SPI_MODE3);
	SPI.setClockDivider( SPI_CLOCK_DIV2 );
	SPI.begin(port);
	//ssp_begin(SPI_CLOCK_DIV1, SPI_MODE0, 9);

	delay( 100 );					//wait 100ms
	digitalWrite( OLED_RES, LOW );
	delay( 100 );
	digitalWrite( OLED_RES, HIGH );	//RESET

	command( SET_DISPLAY_MODE_ALL_OFF );

	command( SET_COMMAND_LOCK );
	data( 0x12 );

	command( SET_COMMAND_LOCK );
	data( 0xb1 );

	command( SET_SLEEP_MODE_ON );

	command( FRONT_CLOCK_DRIVER_OSC_FREQ );
	data( 0xF1 );

	command( SET_MUX_RATIO );
	data( 0x7F );

	command( SET_DISPAY_OFFSET );
	data( 0x00 );

	command( SET_DISPAY_START_LINE );
	data( 0x00 );

	command( SET_REMAP_COLOR_DEPTH );
	data( 0x74 );

	command( SET_GPIO );
	data( 0x00);

	command( FUNCTION_SELECTION );
	data( 0x01 );

	command( SET_SEGMENT_LOW_VOLTAGE );
	data( 0xA0 );
	data( 0xB5 );
	data( 0x55 );

	command( SET_CONTRAST_CURRENT_FOR_COLOR_ABC );
	data( 0xC8 );
	data( 0x80 );
	data( 0xC8 );

	command( MASTER_CONTRAST_CURRENT_CONTROL );
	data( 0x0F );

	command( LOOKUP_TABLE_FOR_GRAYSCALE_PULSE_WIDTH );
	for ( int i = 0; i < GAMMA_LUT_SIZE; i++ )
		data(  gamma_LUT[ i ] );

	//command( USE_BUILT_IN_LINEAR_LUT );

	command( SET_RESET_PRECHARGE_PERIOD );
	data( 0x32 );

	command( ENHANCE_DRIVING_SCHEME_CAPABILITY );
	data( 0xA4 );//data( 0x04 );
	data( 0x00 );
	data( 0x00 );

	command( SET_PRECHARGE_VOLTAGE );
	data( 0x17 );

	command( SET_SECOND_PRECHARGE_VOLTAGE );
	data( 0x01 );

	command( SET_VCOMH_VOLTAGE );
	data( 0x05 );
	command( SET_DISPLAY_MODE_RESET );

	command( SET_COLUMN_ADDRESS );
	data( 0x00 );
	data( 0x7f );

	command( SET_ROW_ADDRESS );
	data( 0x00 );
	data( 0x7f );

	cls();
	//WindowReset();

	digitalWrite(OLED_VCC_ON,HIGH);

	delay( 200 );		//wait 200ms

	command( SET_SLEEP_MODE_OFF );
	return;
}

void MARYOLED::command(int value) {

	digitalWrite(OLED_CS,LOW);
	SPI.transfer(value & 0xff);
	//ssp_transfer(value & 0xFF);
	digitalWrite(OLED_CS,HIGH);
}

void MARYOLED::data(int value) {
	digitalWrite(OLED_CS,LOW);
	SPI.transfer(value | 0x100);
	//ssp_transfer(value | 0x100);
	digitalWrite(OLED_CS,HIGH);
}

void MARYOLED::_window( int x, int y, int width, int height )
{
   int x1 = x + 0;
   int y1 = y + 0;
   int x2 = x1 + width - 1;
   int y2 = y1 + height - 1;

   command( SET_COLUMN_ADDRESS );
   data( x1 );
   data( x2 );
   command( SET_ROW_ADDRESS );
   data( y1 );
   data( y2 );
   command( WRITE_RAM_COMMAND );

}

void MARYOLED::WindowReset(void)
{
	   command( SET_COLUMN_ADDRESS );
	   data( 0 );
	   data( 127 );
	   command( SET_ROW_ADDRESS );
	   data( 0 );
	   data( 127 );
	   command( WRITE_RAM_COMMAND );
}




const unsigned char FONT8x8[97][8] = {
    {0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00}, // columns, rows, num_bytes_per_char
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // space 0x20
    {0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00}, // !
    {0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00}, // "
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // #
    {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00}, // $
    {0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00}, // %
    {0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00}, // &
    {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00}, // '
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // (
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // )
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // *
    {0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00}, // +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // ,
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
    {0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00}, // / (forward slash)
    {0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00}, // 0 0x30
    {0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00}, // 1
    {0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00}, // 2
    {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
    {0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00}, // 4
    {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
    {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00}, // 6
    {0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00}, // 7
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00}, // 8
    {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00}, // 9
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30}, // ;
    {0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00}, // <
    {0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00}, // =
    {0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00}, // >
    {0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00}, // ?
    {0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00}, // @ 0x40
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // A
    {0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00}, // B
    {0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00}, // C
    {0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00}, // D
    {0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00}, // E
    {0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00}, // F
    {0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00}, // G
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
    {0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00}, // J
    {0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00}, // K
    {0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00}, // L
    {0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // M
    {0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00}, // N
    {0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00}, // O
    {0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00}, // P 0x50
    {0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00}, // Q
    {0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00}, // R
    {0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00}, // S
    {0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00}, // T
    {0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00}, // U
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
    {0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00}, // X
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00}, // Y
    {0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00}, // Z
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // [
    {0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00}, // \ (back slash)
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // ]
    {0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00}, // ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // _
    {0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00}, // ` 0x60
    {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00}, // a
    {0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00}, // b
    {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00}, // c
    {0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00}, // d
    {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    {0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00}, // f
    {0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C}, // g
    {0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00}, // h
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    {0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C}, // j
    {0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00}, // k
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    {0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78}, // p
    {0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F}, // q
    {0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00}, // r
    {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
    {0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00}, // t
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00}, // u
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
    {0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00}, // x
    {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C}, // y
    {0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00}, // z
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // {
    {0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00}, // |
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // }
    {0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
    {0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00}
}; // DEL

void MARYOLED::locate(int column, int row) {
    _column = column;
    _row = row;
}

void MARYOLED::newline() {
    _column = 0;
    _row++;
    if (_row >= rows() ) {
        _row = 0;
    }
}

void MARYOLED::_putp( int colour ) {
        /*int cnv = 0;

        cnv  = (colour >> 8) & 0xf800;
        cnv |= (colour >> 5) & 0x07e0;
        cnv |= (colour >> 3) & 0x001f;

        data( cnv >> 8);
        data( cnv );
        */
    unsigned long data1, data2;
    data1 = ((colour >> 8) & 0xff) | 0x100;
    data2 = (colour & 0x0ff) | 0x100;
    data(data1);
    data(data2);
    }
int MARYOLED::_putc(int value) {
    int x = _column * 8;  // FIXME: Char sizes
    int y = _row * 8;
    bitblit(x + 1, y + 1, 8, 8, (char*)&(FONT8x8[value - 0x1F][0]));

    _column++;

    if (_column >= MARYOLED_COLS) {
        _row++;
        _column = 0;
    }

    if (_row >= MARYOLED_ROWS) {
        _row = 0;
    }

    return value;
}

void MARYOLED::cls( void ) {
    	fill( 0, 0, MARYOLED_WIDTH , MARYOLED_HEIGHT, _background );
    	_row = 0;
    	_column = 0;
}


void MARYOLED::window(int x, int y, int width, int height) {
   // digitalWrite( OLED_CS, LOW );
    _window(x, y, width, height);
    //digitalWrite( OLED_CS, HIGH );
}

void MARYOLED::putp(int colour) {
    //digitalWrite( OLED_CS, LOW );
    _putp(colour);
    //digitalWrite( OLED_CS, HIGH );
}


void MARYOLED::pixel(int x, int y, int colour) {
    //digitalWrite( OLED_CS, LOW );
	_window(x, y, 1, 1);
    _putp(colour);
    //digitalWrite( OLED_CS, HIGH );
}

void MARYOLED::fill( int x, int y, int width, int height, int colour )
{
    digitalWrite( OLED_CS, LOW );
    _window( x, y, width, height );

    for (int i = 0; i < width * height; i++ ) {
        _putp( colour );
    }

    _window( 0, 0, MARYOLED_WIDTH, MARYOLED_HEIGHT );
    digitalWrite( OLED_CS, HIGH );
}


void MARYOLED::blit( int x, int y, int width, int height, const int* colour ) {
    digitalWrite( OLED_CS, LOW );
    _window( x, y, width, height );

    for (int i = 0; i < width * height; i++ ) {
        _putp( colour[i] );
    }
    _window( 0, 0, MARYOLED_WIDTH, MARYOLED_HEIGHT );
    digitalWrite( OLED_CS, HIGH );
}


void MARYOLED::bitblit( int x, int y, int width, int height, const char* bitstream ) {
    digitalWrite( OLED_CS, LOW );
    _window( x, y, width, height );

    for (int i = 0; i < height * width; i++ ) {
        int byte = i / 8;
        int bit = i % 8;
        int colour = ((bitstream[ byte ] << bit) & 0x80) ? _foreground : _background;
        _putp( colour );
    }
    _window( 0, 0, _width, _height );
    digitalWrite( OLED_CS, HIGH );
}

void MARYOLED::foreground(int c) {
    _foreground = c;
    return;
}

void MARYOLED::background(int c) {
    _background = c;
    return;
}

int MARYOLED::width() {
    return MARYOLED_WIDTH;
}

int MARYOLED::height() {
    return MARYOLED_HEIGHT;
}

int MARYOLED::columns() {
    return MARYOLED_COLS;
}

int MARYOLED::rows() {
    return MARYOLED_ROWS;
}


